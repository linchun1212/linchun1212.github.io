{"meta":{"title":"Welcome to my world","subtitle":null,"description":null,"author":"LinChun","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"关于juery基本知识点汇总","slug":"juery基本知识点汇总","date":"2019-06-24T06:56:51.000Z","updated":"2019-06-24T07:10:46.054Z","comments":true,"path":"2019/06/24/juery基本知识点汇总/","link":"","permalink":"http://yoursite.com/2019/06/24/juery基本知识点汇总/","excerpt":"jquery简介jquery就是由原生js封装出来的一个方法（函数）库而已，封装的思想为面向对象思想 传统的概念：无论PC、mobile端的网站 ，在开发界面的时候，不使用任何框架（ vue、react、angular.js ）而且传统的网站开发，我们写特效的时候，操作DOM是必不可少的。而且我们使用原生js选元素是非常麻烦的。所以在06年时候 jquery出现了（最初解决选元素的问题） 只要会css，你就会使用jquery选元素。 传统的PC端网页开发 传统的移动端网页开发 经过这几年的更新迭代，开发者|架构师也越来越觉得 页面与数据分开会更好（ 后端只给前端数据【json】 ）这种技术就叫spa（ single page aplication ）而且越来越少的操作DOM元素了。 认识jQuery是一个快速，小巧，功能丰富的JavaScript库。它通过易于使用的API在大量浏览器中运行，使得HTML文档遍历和操作，事件处理，动画和Ajax变得更加简单。通过多功能性和可扩展性的结合，jQuery改变了数百万人编写JavaScript的方式。 只不过是一个工具 逻辑思想我还还得有 使用工具的原则是 提高我们的开发效率的。","text":"jquery简介jquery就是由原生js封装出来的一个方法（函数）库而已，封装的思想为面向对象思想 传统的概念：无论PC、mobile端的网站 ，在开发界面的时候，不使用任何框架（ vue、react、angular.js ）而且传统的网站开发，我们写特效的时候，操作DOM是必不可少的。而且我们使用原生js选元素是非常麻烦的。所以在06年时候 jquery出现了（最初解决选元素的问题） 只要会css，你就会使用jquery选元素。 传统的PC端网页开发 传统的移动端网页开发 经过这几年的更新迭代，开发者|架构师也越来越觉得 页面与数据分开会更好（ 后端只给前端数据【json】 ）这种技术就叫spa（ single page aplication ）而且越来越少的操作DOM元素了。 认识jQuery是一个快速，小巧，功能丰富的JavaScript库。它通过易于使用的API在大量浏览器中运行，使得HTML文档遍历和操作，事件处理，动画和Ajax变得更加简单。通过多功能性和可扩展性的结合，jQuery改变了数百万人编写JavaScript的方式。 只不过是一个工具 逻辑思想我还还得有 使用工具的原则是 提高我们的开发效率的。 使用jquery两种写法 $( css形式的选择器 ).action() 选择元素以后要干嘛 $.工具方法() 不操作元素（不操作DOM）$.isArray() 123new Date()// 时间对象new RegExp() // 正则对象new Person() //person对象 /* jquery的原型上的方法，只能是实例出来的对象使用（也就是说使用 $()选择的元素才能 点 操作 ） */var r = $( ‘button’ ) //-&gt; 返回的是一个jquery对象，前面不用写newconsole.log( typeof r )//object jQuery对象与DOM对象 jQuery： 就是通过jQuery包装DOM对象后产生的对象。jQuery对象是jQuery独有的。如果一个对象是jQuery对象，那么就可以使用jQuery中的原型上的方法 DOM对象：通过原生方法得到的DOM元素就是DOM对象DOM对象可以使用javascript中的方法 可以同时存在，但是不能滥用 123456/*错误的写法bts[1].css()$(&apos;button&apos;).innerHTML = 123 */ jquery的方法函数化当我想要使用某个功能，基本上jquery上一定有一个函数供我们调用。 TeleportUltra的使用jQuery使用的时候, $冲突的问题解决/* 使用匿名函数 + jQuery.noConflict() */ jQuery.noConflict()//把全局下的 jQuery中的$ 给销毁 ;(function ( $ ) { 12//console.log( $,&apos;我是函数内部的&apos; )$(&apos;button&apos;).css(&apos;background&apos;,&apos;blue&apos;) })( jQuery ) 页面加载问题 原生：window.onload = function() {}jquery： $(document).ready(function() {}) $().ready(function() {}) $(function() {});区别：执行时机：原生的必须等待网页中所有的内容加载完毕后（包括图片）才能执行。而jQuery是网页中所有DOM结构绘制完毕后就执行，可能DOM元素关联的东西并没有加载完编写个数：原生的只通写一个，而jQuery的可以编写多个。 jquery的链式操作只要返回jquery对象，就一直能够 点下去 jquery当中的事件绑定$(元素).click(function(){ }) 强大的选择器基本选择器//$(‘标签名’) 帮我们省略了迭代（循环）$(‘p’).css(‘background’,’red’) //$(‘.class名’)$(‘.abc’).css(‘background’,’blue’) //$(‘#ID名’)$(‘#div1’).css(‘background’,’pink’) eeee $(‘#div a b c d’) 层次选择器 $(‘a b’)：获取a元素的后代元素b $(‘a&gt;b’)：获取a元素的直接后代元素b $(‘a+b’)：获取紧跟在a元素后面的b元素，next()方法一样的效果 $(‘a~b’)：获取a元素后面的所有b元素，nextAll() 方法一样的效果 prev()：返回上一个兄弟节点，不是所有的兄弟节点 || next()使用prev和next就不要传参，没有意义 ,一定是紧挨着 prevAll(选择器)：返回所有之前的兄弟节点 || nextAll siblings(选择器)：返回兄弟姐妹节点，不分前后 基本的过滤选择器 $(‘li:first’)：获取第一个li元素 $(‘li:last’)：获取最后一个li元素 $(‘li:not(.box)’)：获取所有的li，除了class名为box的 $(‘li:even’)：获取索引为偶数的li元素 $(‘li:odd’)：获取索引为奇数的li元素 $(‘li:eq(2)’)：获取索引值为2的li元素 $(‘li:gt(2)’)：获取索引大于2的li元素 $(‘li:lt(2)’)：索引小于2的li元素- jquery当中的循环 $.each(对象, function (下标, 当前项){}); // 可以针对原生，也可以针对jQuery对象第二个参数是一个函数，这个函数有两个参数，一个是下标，一个是当前项，这个函数中的this也即当前项 jQuery对象.each(function (下标, 当前项){}); 只能针对jQuery对象该方法用于循环jQuery对象，这个方法接收一个函数做为参数，这个函数的有两个参数第一个参数为下标，第二个参数为项，这个函数中的this即项 选项卡 this 123456 $(&apos;button&apos;).click(function () &#123; console.log(123) console.log( this )//原生DOM 对象 //this.style.background = &apos;red&apos; $(this).css(&apos;background&apos;,&apos;yellow&apos;)// $(this)//jquery对象&#125;) hide()隐藏 show()显示 parent|next|prev获取父元素 index获取元素所在兄弟中的索引位置 addClass添加class removeClass移除class children(选择器)选择子元素","categories":[],"tags":[]},{"title":"匿名函数与闭包小结","slug":"匿名函数与闭包小结","date":"2019-06-24T06:50:29.000Z","updated":"2019-06-24T06:52:32.731Z","comments":true,"path":"2019/06/24/匿名函数与闭包小结/","link":"","permalink":"http://yoursite.com/2019/06/24/匿名函数与闭包小结/","excerpt":"函数回顾 普通的函数定义 123function fn(arg1,arg2)&#123; &#125; 函数的表达式 （ 由数据和运算符组成的式子叫做表达式 ） 123var fn = function()&#123; &#125; 构造函数( 特点：大驼峰式命名 ) 1实例化对象的 new 构造函数() 事件处理函数 1234567891011121314document.onclick = function( e )&#123; 当事件触发以后，会产生事件对象 var ev = window.event || e 1. this 2. 事件对象 3. 冒泡 4. 默认行为 5. 事件兼听 6. 事件源 7. 事件源+冒泡（ 事件委托|事件代理 ） 8. 右击（环境菜单事件）、键盘事件、滚轮事件（方向的判断） 9. 拖拽（ mousedown mousemove mouseup ） IE的全局补获&#125; 函数的表达式除了不能在定义前使用，其它的特点和函数声明一模一样。 `","text":"函数回顾 普通的函数定义 123function fn(arg1,arg2)&#123; &#125; 函数的表达式 （ 由数据和运算符组成的式子叫做表达式 ） 123var fn = function()&#123; &#125; 构造函数( 特点：大驼峰式命名 ) 1实例化对象的 new 构造函数() 事件处理函数 1234567891011121314document.onclick = function( e )&#123; 当事件触发以后，会产生事件对象 var ev = window.event || e 1. this 2. 事件对象 3. 冒泡 4. 默认行为 5. 事件兼听 6. 事件源 7. 事件源+冒泡（ 事件委托|事件代理 ） 8. 右击（环境菜单事件）、键盘事件、滚轮事件（方向的判断） 9. 拖拽（ mousedown mousemove mouseup ） IE的全局补获&#125; 函数的表达式除了不能在定义前使用，其它的特点和函数声明一模一样。 ` 匿名函数应用 匿名函数：就是定义时未直接指定名称的函数 优点：节省内存空间 匿名函数与有名字的函数的区别 非匿名函数在定义时，就已经创建函数对象和作用域对象。所以，即使未调用，也占用内存空间； 匿名函数，仅在调用时，才临时创建函数对象和作用域链对象；调用完，立即释放，所以匿名函数比非匿名函数更节省内存空间。 匿名函数定义的多种形式以下fn是 function(){}的简写 匿名函数自执行 (fn)() !fn() -fn() +fn() 闭包的应用关于闭包解释 闭包就是函数嵌套函数，函数内部的变量可以访问外部的变量（作用域链），当实现闭包以后，则函数内部的变量长期驻扎在内存当中 全局变量其实就是闭包的一种（ 并且局部变量本身不会长期驻扎在内存当中的 ） 12345678910111213141516171819202122/* 在fn1函数中的局部变量和函数，都属于 fn1的私有成员（ 在fn1外部是访问不到的。 ） */function fn1() &#123; var a = 1 //变量a、b、c、d.... function fn2()&#123; //fn2、fn3、.... a = a + 1 console.log( a ) &#125; return fn2// return 出去的函数如果在外部变量接收了，它俩指向的不是一个地址。&#125;var sss = fn1()// 函数// console.log( sss )sss()sss() 解决我们之前函数封装的全局问题 使用对象表示法存储数据( 命名空间 ),好处是解决了全局变量的污染,也不安全 12345678910111213var tools = &#123; jia:function(a,b)&#123; return a + b &#125;, jian:function(a,b)&#123; return a - b &#125;&#125;tools.cheng = function(a,b)&#123; return a*b&#125; 1.下面代码执行后的结果是？如何处理 12345678var arr = []; for(var i = 0;i&lt;10;i++)&#123; arr.push(function () &#123; console.log(i); &#125;) &#125; //[function,function,function,function,function,function,function,function] arr[6](); //获取数组中下标为6的函数,调用 123456789var arr1 = [];for(var i = 0;i&lt;10;i++)&#123; (function (i) &#123; arr1.push(function () &#123; console.log(i); &#125;) &#125;)(i)&#125;arr1[6](); 3.执行结果 123456for(var i = 0;i&lt;5;i++)&#123; setTimeout(function () &#123; console.log(i,new Date()); &#125;,1000);&#125;console.log(i,new Date()); 关于分号一行代码末尾，没有分号，没有什么不好。全凭个人风格。如果一行代码前面是 ( [ `` 这三种情况开头的，需要在行首加分号。其它情况都可以不加 当我们想要使用匿名函数中返回值 ，则需要使用 (fn)() 使用 (fn)()种形式，需要在前面加分号。不加的话会报错。","categories":[],"tags":[]},{"title":"ajax的认知","slug":"ajax的认知","date":"2019-06-24T06:39:29.000Z","updated":"2019-06-24T06:47:11.967Z","comments":true,"path":"2019/06/24/ajax的认知/","link":"","permalink":"http://yoursite.com/2019/06/24/ajax的认知/","excerpt":"ajax技术 封装一个ajax（不要求你会封装），ajax原理需要懂 ajax是干什么 你会用我封装ajax这个函数 在jquery当中有现在的封装好的ajax方法 4阶段学习框架的时候，框架里面都有集成好的ajax方法 理解程序中的异步和同步 使用ajax注意事项 ajax需要依赖服务器环境（安装的phpstudy集成了服务器环境，运行phpstudy） 项目当中哪些地方可以使用ajax？","text":"ajax技术 封装一个ajax（不要求你会封装），ajax原理需要懂 ajax是干什么 你会用我封装ajax这个函数 在jquery当中有现在的封装好的ajax方法 4阶段学习框架的时候，框架里面都有集成好的ajax方法 理解程序中的异步和同步 使用ajax注意事项 ajax需要依赖服务器环境（安装的phpstudy集成了服务器环境，运行phpstudy） 项目当中哪些地方可以使用ajax？ 详解ajax流程在程序中 ajax.readyState == 4只是代表这件事情做过了，不代表成功了。 ajax.status == 200的时候，才代表这件事情请求成功了。 而ajax天生就是做异步的，也就是说在使用ajax请求的时候，不请求鼠标的其它操作。传统的网页请求，没有请求完成，一定是正在加载。ajax请求，你看不出来页面正在刷新。网站中哪里都用到了ajax股票网站、直播、聊天。实时更新的功能都可以使用ajax（ 无需整个页面加载 ） 代码实现123456789101112131415//1. 创建一个ajax对象，是一个浏览器 var ajax = new XMLHttpRequest()//全局函数，创建一个ajax对象 ,IE6不支持//2. 告诉ajax请求哪个地址ajax.open(&apos;get&apos;,&apos;a.txt&apos;,true)//3. 使用ajax主动发送请求ajax.send()////4. 有请求必然有响应。ajax.onreadystatechange = function () &#123;// if( ajax.readyState == 4 ) &#123; if( ajax.status == 200 )&#123;// console.log( ajax.responseText )// ajax.responseText 请求文件的结果 &#125; &#125;&#125; 又讲回调函数 在ajax中只有状态码为200的时候（成功的条件），要做的事情，成功的回调函数 失败了要做的事情，则是失败的回调 而且我们使用ajax请求，一定（100%）你一定要写成功要做的事情（不写成功要做的事情就不符合我们的要求）。。而且一定一定不是return出来这个结果。 json字符串与对象 对象 Object| new {} 12345- &#123; a:&apos;abc&apos; &#125;&quot;&#123;a:&apos;123&apos;&#125;&quot; json字符串|string. var json = ‘{“a”: “Hello”, “b”: “World”}’; //这是一个 JSON 字符串，本质是一个字符串 严格的json字符串协议是？ 属性必须是双绰号，属性对应的value值如果是字符串类型也必须是双引号。而且json字符串中就不应该有函数类型的数据。 99%的情况 json字符串中的数据（字符串、数值、布尔值） 1var json = &apos;&#123;&quot;s&quot;:&quot;abcd&quot;,&quot;n&quot;:18,&quot;b&quot;:&quot;true&quot;&#125;&apos; json字符串有两种形式 一种是纯花括号 另一种可以是数组形式’[{“s”:”abcd”,”n”:18,”b”:”true”},{“s”:”abcd”,”n”:18,”b”:”true”}]’ ‘[11,22,33]’ JSON js的内置对象 和Math对象的形式很相似 JSON.parse: 把json字符串转换成对象 JSON.stringify：把对象转换成json字符串 1234567&#123;&quot;result&quot;: [ &#123;&quot;name&quot;:&quot;ujiuye&quot;,&quot;age&quot;:18&#125;, &#123;&quot;name&quot;:&quot;ujiuye&quot;,&quot;age&quot;:18&#125; ]&#125;","categories":[],"tags":[]},{"title":"cookie、正则、面向对象的理解","slug":"cookie、正则、面向对象的理解","date":"2019-06-24T06:30:18.000Z","updated":"2019-06-24T06:38:24.652Z","comments":true,"path":"2019/06/24/cookie、正则、面向对象的理解/","link":"","permalink":"http://yoursite.com/2019/06/24/cookie、正则、面向对象的理解/","excerpt":"COOKIECOOKIE 的特性（特点） 后端的技术（简单的了解一下） 真正的域名/文件夹/文件名.html 下个阶段还会再讲到cookie|session 使用cookie存储一个值（只能以字符串形式存储） 其它特性 Cookie 是浏览器访问服务器后，服务器传给浏览器的一段数据。 浏览器需要保存这段数据，不会轻易删除（保存在计算机中）。 此后每次浏览器访问该服务器，都必须带上这段数据。 Cookie存储容量为4KB 123456[&#123;name:&apos;iphonex&apos;,price:1590,nums:10&#125;,&#123;name:&apos;香奈尔&apos;,price:2000,nums:20&#125;]` product=[&#123;name:&apos;iphonex&apos;,price:1590,nums:10&#125;,&#123;name:&apos;香奈尔&apos;,price:2000,nums:20&#125;] `document.cookie = &apos;key1=value1&apos;document.cookie = &apos;key2=value2&apos; 过期时间设置的语法document.cookie = “key=value;expires=时间对象”; 设置cookie（ 保存一个数据 ） cookie 是保存在用户端的（我们可以通过用户端浏览器查看） cookie 如果没有设置过期时间，关闭浏览器cookie自动消失（不是关闭标签页） 我设置的cookie的代码在 01cookie语法.html 文件中，而这个文件在cookie文件夹下。其它页面也可以访问到这个页面设置的cookie（条件：只能在01cookie语法.html 所处的当前文件夹下或它的子目录下） cookie也能实现页面之间共享数据（ 同一个浏览器 ）也就是说虽然能共享数据但是局限于同一个浏览器 过期时间 document.cookie = “key=value;expires=时间对象”;","text":"COOKIECOOKIE 的特性（特点） 后端的技术（简单的了解一下） 真正的域名/文件夹/文件名.html 下个阶段还会再讲到cookie|session 使用cookie存储一个值（只能以字符串形式存储） 其它特性 Cookie 是浏览器访问服务器后，服务器传给浏览器的一段数据。 浏览器需要保存这段数据，不会轻易删除（保存在计算机中）。 此后每次浏览器访问该服务器，都必须带上这段数据。 Cookie存储容量为4KB 123456[&#123;name:&apos;iphonex&apos;,price:1590,nums:10&#125;,&#123;name:&apos;香奈尔&apos;,price:2000,nums:20&#125;]` product=[&#123;name:&apos;iphonex&apos;,price:1590,nums:10&#125;,&#123;name:&apos;香奈尔&apos;,price:2000,nums:20&#125;] `document.cookie = &apos;key1=value1&apos;document.cookie = &apos;key2=value2&apos; 过期时间设置的语法document.cookie = “key=value;expires=时间对象”; 设置cookie（ 保存一个数据 ） cookie 是保存在用户端的（我们可以通过用户端浏览器查看） cookie 如果没有设置过期时间，关闭浏览器cookie自动消失（不是关闭标签页） 我设置的cookie的代码在 01cookie语法.html 文件中，而这个文件在cookie文件夹下。其它页面也可以访问到这个页面设置的cookie（条件：只能在01cookie语法.html 所处的当前文件夹下或它的子目录下） cookie也能实现页面之间共享数据（ 同一个浏览器 ）也就是说虽然能共享数据但是局限于同一个浏览器 过期时间 document.cookie = “key=value;expires=时间对象”; 123410秒钟以后过期var t1 = new Date()t1.setSeconds( t1.getSeconds()+10 )document.cookie = &apos;key=value;expires=&apos;+t1 123451天以后过期var t1 = new Date()var oneDayAfter = 1*24*60*60t1.setSeconds( t1.getSeconds()+oneDayAfter )document.cookie = &apos;key=value;expires=&apos;+t1 获取cookie（ 获取你保存的值 ）username=admin; age=18 username=admin&amp;age=18{ username:&apos;admin&apos;, age:18} 删除cookie（ 删除保存的值 ） 做案例 phpstudy 解压到你所在的盘符 如果以后，你想使用phpstudy，请启动phpstudy这个软件 把你自己的文件放到www目录下http://localhost/ 指向到你www所在的目录。比如www/a.txt http://localhost/a.txtD:\\phpStudy\\WWW\\js_study\\aa.html http://localhost/js_study/aa.html 正则表达式 作用：就是操作字符串，验证一个字符串是否符合一些规则。 正则对象：RegExp正则表达式：是对字符串操作的一种逻辑公式，就是用事先定义好的一些特殊字符，及这些特定字符的组合，组成一个‘规则字符串’，这个规则字符串用来表达对字符串的一种过滤逻辑规定文本检索的内容 ， 正则应用场景 用来检索 替换文本 创建正则不会写正则，先写正确的，正确的也不会写，百度吧。 12345回忆- 构造函数创建数组new Array()- 字面量形式创建数组[] 构造函数创建 new RegExp(‘检索字符’,’修饰符’)var pat1 = new RegExp(‘hello’); 字面量创建 /检索字符/修饰符var pat2 = /hello/; 元字符这些字符在正则当中表示一些特殊的含义。比如：\\d-&gt;表示数字0-9 元字符/元符号 匹配情况. 匹配除换行符外的任意字符[a-z0-9] 匹配括号中的字符集中的任意字符[^a-z0-9] 匹配任意不在括号中的字符集中的字符\\d 匹配数字\\D 匹配非数字，同[^0-9]相同\\w 匹配字母和数字及_ \\W 匹配非字母和数字及_ \\s 匹配空白字符、空格、制表符和换行符\\S 匹配非空白字符\\b 匹配字符边界^ 行首匹配$ 行尾匹配 修饰符 修饰符，比如：忽略大小写 i：ignore g: global 全局匹配( 全部搜索 ) 正则是比较懒的，只要匹配上它就不再往下继续查找。 量词的概念 ( 数量 ){n,m} : 至少n次至多m次+: 至少1次，至多无限制\\d 一个\\d 就代表一位数字3个数字 \\d\\d\\d\\d{3} 正则一个对象（ 有一些方法 ） test: 检测 regObj.test( 你要检测的字符串 ) 匹配成功返回true否则为false regObj.exec( 你要检测的字符串 ) 匹配成功，返回其字符的位置和其它相关信息( 且是一个数组信息 )，如果匹配不成功则返回null 123456789101112var str = &apos;abcABC&apos;var reg = /b/ivar result = reg.exec( str )// result: 0: &quot;b&quot;groups: undefinedindex: 1input: &quot;abcABC&quot;length: 1 字符串方法的一些回忆 strObj.indexOf( string )// 只能传字符串类型的值 strObj.replace() strObj.replace: 替换正则匹配的字符串 strObj.match : 返回正则匹配到的内容,跟exec方法一样 strObj.search：返回正则匹配到的第一个字符串的位置，没有返回-1 split 正则总结及其它 匹配对应的字符：word 元字符（\\d \\w \\s .） .匹配. + + \\符号 量词{} + 行首行尾 使用一个正则匹配完成的字符串（表单验证比较多） 中括号以及中括号当中的 ^非 区间- 修饰符 ig 大部分情况用g 和match一起使用 12match 使用greplace 使用g（全部替换） 一些方法字符串的方法stringObj.indexOf( string )stringObj.search( reg/string )stringObj.split()stringObj.match()stringObj.replace() 正则的方法regObj.test(string)regObj.exec(string) split 或 | 小括号分组 量词 去除首尾空格 量词元字符/元符号 匹配情况x? 匹配0个或1个x 可有可无 {0,1} (010-)?66668888x* 匹配0个或任意多个xx+ 匹配至少一个x(xyz)+ 匹配至少一个(xyz)x{m,n} 匹配最少m个、最多n个x x{1,} == x+ var str = ‘absdf asdf adsfsafd’ \\s* 123面向对象ajax闭包 面向对象 思想（整体思想） 把我们以前学的知识做一个总结（ 从整体考虑去实现某一个功能 ） 对象一定是有功能的，你想使用某一个功能一定是去找具体这个功能的对象 12345### 对象构成： - 属性 ：变量 - 方法 ：函数#### 关于不同的对象- 不同的对象肯定有不同的属性和方法 1234567var person = &#123; name:&apos;xxx&apos;, age:&apos;xxx&apos;, sing:function()&#123; &#125;&#125; 只有确定性的指定某一个对象，我才知道这个对象有哪些属性和哪些功能方法 面向对象的3个特点 封装把对象的功能实现（ 函数封装 ） 继承 12345678910人：最普通的父类（原始类、基类） 姓名，性别，年龄，家庭住址警察police： 从基础类 人 继承出来 警官证 抓坏人医生 医师资格证 面向对象主要学习2个点 使用对象 更加关心会使用就行，无需关心内部细节 window|document|div|obtn 创建对象 扮演写对象的人 创建对象 字面量形式快速创建var obj = {} 一张白纸 1234567891011121314151617 名称 身高 逗你玩儿var dog1 = &#123; name:&apos;二哈&apos;, height:&apos;50公分&apos;, douniwan:function () &#123; console.log(&apos;汪汪汪~~~~&apos;) &#125;&#125;console.log( dog1 )dog1.douniwan()console.log( dog1.height )console.log( dog1.name ) 通过Object函数进行 new实例化创建对象 1234567891011121314// 这种方式就叫工厂方式 : 工厂方式等同于 字面量形式快速创建function createDog( name2,height2 )&#123; var dog = new Object() // new Object()和参数是原材料 // console.log( dog1 ) // 从这行开始至return 都是对原材料的加工处理 dog.name = name2; dog.height = height2 dog.douniwan = function ( call ) &#123; console.log( call ) &#125; return dog // 出厂&#125; 123+ 工厂方式的问题 1. 创建对象前面没有new关键字 2. dog1.douniwan == dog2.douniwan //false 对象上的方法不共用，如果在同一个页面创建很多个对象则，会产生资源浪费 构造函数 又可以称为“类” 大驼峰式命名 创建对象的 Date/Array/RegExp 1234567891011121314// 这种方式的函数就叫 构造函数，只不过构造函数创建对象function CreateDog( name2,height2 )&#123; //var dog = new Object() // new Object()和参数是原材料 //this = new Object() this.name = name2; this.height = height2 this.douniwan = function ( call ) &#123; console.log( call ) &#125; //return dog // 出厂 //return this&#125; 原型 在js内部，只要是函数都有prototype属性（ 原型 ），数据类型为Object prototype[原型]，本质上是为构造函数提供的 我们以Array构造函数为例 因为Array是一个函数，所以Array也有prototype属性，并且Array是js提供的，而且上面自带了很多的方法 每一个实例的对象（实实在在的数据对象） 都有一个proto 这个属性，它指向 创建这个对象的构造函数的prototype上 var arr1 = new Array(11,22) // var arr1 = [11,22]arr1.proto === Array.prototype 正是因为每一个实例对象的proto 指向的是一个东西，并且每一个实例对象都能访问到 构造函数prototype的属性。所以每一个方法共用了 原型的注意事项 js内部为我们提供的构造函数，它的prototype原型上你可以为其添加其它属性或方法，每一个实例对象都可以访问你添加的方法 注意别把人家原型上的方法 给替换了。 实例化对象 字面量形式快速创建对象（叫实例化对象） 通过构造函数创建对象 new 函数名（） 实例化对象 混合创建 （类） 构造函数+原型 混合创建与工厂方式与字面形式创建 工厂方式与字面量形式创建对象 是一模一样的应用场景（ 如果一个页面，只存在一个对象 工厂方式和字面量形式是可以使用的 ） 123456&#123; name:&apos;&apos;, price:&apos;&apos;, buy:function()&#123;&#125;, addShopCart:function()&#123;&#125;&#125; 当一个页面有很多很多由同一个构造函数创建出来的对象的时候，就不能使用工厂方。而是使用（构造函数+原型 ） 关于call函数和apply函数这两个函数都能够改变函数中的this指向，如果不想改变，在使用call和apply的时候传一个null这两个函数在调用的时候，第一个实参就是函数中的this。函数声明会有形参，从call和apply的第2个参数开始才是具体的实参 apply的后面的具体的实参，需要传一个数组任何函数上面都有call和apply属性，只不过这两个属性存储的是函数 12345678910fuction fn(a,b)&#123; console.log(this) console.log( a,b )&#125;fn()//windowfn.call() | fn.apply()fn.call(null) | fn.apply(null), 函数当中的this没有被改变fn.call( null,1,2 ) 实现继承 构造函数中的属性 构造函数原型上的方法 子类当中可能会有自己的属性和方法 实现继承的以后，修改子类不能影响父类 继承的原理： 就是因为面向对象当中 有原型链： proto 实现对象才有 proto ,构造函数有的 是原型： prototype var arr = [] ===&gt; var arr = new Array() arr.proto === Array.prototype //true Object.prototype.proto。 当原型链条找到这里还没有找到某属性，则返回undefined 怎样写对象不会有问题 函数写到原型上 属性（写到构造函数中） 继承方式 原型链继承子类.prototype = new 父类() 冒充继承 call 和 apply 只继承构造函数中的属性 使用for_in继承原型上的属性 123for(var attr in A.prototype)&#123;B.prototype[attr] = A.prototype[attr]//一项一项的赋值。并没有改变B.prototype的地址&#125;","categories":[],"tags":[]},{"title":"关于js中事件的小小总结","slug":"关于js中事件的小小总结","date":"2019-06-24T06:23:26.000Z","updated":"2019-06-24T06:24:57.529Z","comments":true,"path":"2019/06/24/关于js中事件的小小总结/","link":"","permalink":"http://yoursite.com/2019/06/24/关于js中事件的小小总结/","excerpt":"事件事件对象当时事件发生的时候，所以跟事件相关的信息(事件类型，事件目标，鼠标位置等)都会存储在事件对象event中。 事件对象必须在函数当中获取 必须是事件函数当中才有事件对象 window.event || ev IE和谷歌可以通过window.event获取。火狐使用 事件函数的参数获取事件对象 事件对象的一些属性 type:事件类型 target(srcElement(ie8-))：事件目标|事件源事件源兼容写法 var _this = ev.target || ev.srcElement clientX，clientY：鼠标位置，相对于屏幕(相对于可视区) pageX，pageY：鼠标位置，相对于页面（低版本IE不兼容） 1234兼容写法var scrollTop = document.body.scrollTop || document.documentElement.scrollTop var scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeftalert( ev.clientY + scrollTop ) ctrlKey，shiftKey，altKey：是否按住了这些功能键如果按下则为true，否则为false","text":"事件事件对象当时事件发生的时候，所以跟事件相关的信息(事件类型，事件目标，鼠标位置等)都会存储在事件对象event中。 事件对象必须在函数当中获取 必须是事件函数当中才有事件对象 window.event || ev IE和谷歌可以通过window.event获取。火狐使用 事件函数的参数获取事件对象 事件对象的一些属性 type:事件类型 target(srcElement(ie8-))：事件目标|事件源事件源兼容写法 var _this = ev.target || ev.srcElement clientX，clientY：鼠标位置，相对于屏幕(相对于可视区) pageX，pageY：鼠标位置，相对于页面（低版本IE不兼容） 1234兼容写法var scrollTop = document.body.scrollTop || document.documentElement.scrollTop var scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeftalert( ev.clientY + scrollTop ) ctrlKey，shiftKey，altKey：是否按住了这些功能键如果按下则为true，否则为false 事件绑定 为元素添加事件 为元素绑定事件 事件兼听 123document.onclick = function()&#123; &#125; 传统的事件绑定的写法弊端 后面的事件绑定会把前面的事件绑定给覆盖 有时候我们具体的业务就需要为元素绑定多个相同的事件名 既然需要分开绑定事件函数了，所以这两个事件函数是没有关系的。 事件兼听 标准浏览器：元素.addEventListener(‘事件类型(加on)’，事件处理函数，是否捕获)事件函数正序执行this没有问题 ie浏览器：元素.attachEvent（’事件类型（加on）’，事件处理函数）事件函数倒序执行this指向window 12var _this = ev.srcElement || ev.target _this.style.background = &apos;red&apos; function bind(ele,type,fn){ } 事件取消 document.onclick = fn1 -&gt; document.onclick = null document.addEventListener( ‘click’,fn1 ) - document.removeEventListener( ‘click’,fn1 ) document.attachEvent( ‘onclick’,fn1 ) document.detachEvent( ‘onclick’,fn1 ) 事件流 元素.addEventListener（事件类型，事件处理函数，是否捕获）false：冒泡 必须掌握true：捕获 了解 IE没有捕获流，只有标准浏览器才有捕获流 事件捕获阶段：当事件发生的时候，事件从window开始依次往子元素传递确定目标阶段：找到目标事件冒泡阶段：从事件目标开始处理事件，处理完以后依次往父元素传递，一直传到window ,我们所有传统的事件绑定都是事件冒泡机制,而且IE只有冒泡机制（只有冒泡事件流） 注意：冒泡阶段处理，ie只有冒泡 关于事件操作 只要是关于事件相关的一些操作，100% 都是通过事件对象ev 事件冒泡的问题 阻止冒泡函数：ev.stopPropagation 老版本的谷歌或火狐 ，IE不支持 属性：ev.cancelBubble IE，现在谷歌已经支持ev.stopPropagation ? ev.stopPropagation() : ev.cancelBubble = true 事件的默认行为（浏览器的默认行为） 浏览器有很多的默认行为。例如：点击超链接跳转，点击右键会弹出菜单，滑动滚轮控制滚动条。 添加事件的方式 阻止事件默认行为 哪个事件触发的默认行为，就在哪个元素事件函数当中去阻止（你想阻止了） 123- 元素.事件 return false( 写到函数末尾 ) | ev.preventDefault()[ 标准浏览器下才有的方法 ]- addEventListener ev.preventDefault()- attachEvent ev.returnValue = false 如果使用return false阻止，则必须写到事件函数的后面，你要是写前面，后面的代码不会执行 冒泡+事件源（ 事件委托|事件代理 ）事件代理： 找一个元素（父元素）代理，当事件发生的时候，由这个元素通知具体的元素去处理事件原理 ： 将事件加在父元素身上，当事件发生的时候，通过事件目标获取到具体的子元素，去处理事件好处：1:提高性能 2:让后面添加的子元素同样有效果( 传的绑定事件，新增的元素是没有事件 ) 把事件添加到子元素上，但是委托给父元素","categories":[],"tags":[]},{"title":"关于BOM的操作","slug":"关于BOM的操作","date":"2019-06-06T13:34:18.000Z","updated":"2019-06-06T13:35:56.911Z","comments":true,"path":"2019/06/06/关于BOM的操作/","link":"","permalink":"http://yoursite.com/2019/06/06/关于BOM的操作/","excerpt":"BOMBrowser Object Model，和我们浏览器的相关操作，都在BOM里面。 在前端、window属于全局的变量、global 全局变量、全局的函数都属于window 常用系统对话框 alert()：在页面弹出警告框 （window.alert()可以省略window） 就是单纯的弹出，没有返回值 console.log()：在控制台打印信息 在控制台输出，没有返回值 confirm(‘是否重置’)：带确认的对话框 返回boolean值，true：确定，false：取消 经常作为判断条件。","text":"BOMBrowser Object Model，和我们浏览器的相关操作，都在BOM里面。 在前端、window属于全局的变量、global 全局变量、全局的函数都属于window 常用系统对话框 alert()：在页面弹出警告框 （window.alert()可以省略window） 就是单纯的弹出，没有返回值 console.log()：在控制台打印信息 在控制台输出，没有返回值 confirm(‘是否重置’)：带确认的对话框 返回boolean值，true：确定，false：取消 经常作为判断条件。 12345if( confirm(&apos;你满18了吗？&apos;) )&#123; confirm执行完得到的返回值做为if的判断条件 console.log(&apos;满18&apos;) &#125;else&#123; console.log(&apos;未成年&apos;) &#125; prompt(‘title的提示信息’,’默认输入框的内容’)：带输入的对话框 确定：返回输入的内容 取消：返回null 窗口打开与关闭( 了解 ) 起全局变量的时候，应该避开name。 window.open( url,名字,窗口样式 ) 会返回一个新的window对象 默认新窗口打开 名字：_self当前页面 _blank 新窗口打开,我们可以给window窗口自己起名字 当我们指定_self、_blank以外的名字，作用：可以快速定位 window.close() location地址栏对象 **** http://www.w3school.com.cn/jsref/dom_obj_location.asp URLURL（Uniform Resource Locator,统一资源定位符），它是WWW的统一资源定位标志，就是指网络地址。protocol :// hostname[:port] / path / [;parameters][?query]#fragment http://nodejs.cn/api/url.html#url_url_strings_and_url_objects http://www.aaa.com:8080/p/a/t/h/aaa.html?name=admin&amp;age=18#div1 http://www.ujiuye.com/ hash 设置或返回从井号 (#) 开始的 URL（锚）。 *** host 设置或返回主机名和当前 URL 的端口号。 hostname 设置或返回当前 URL 的主机名。 href 设置或返回完整的 URL。 *** pathname 设置或返回当前 URL 的路径部分。 port 设置或返回当前 URL 的端口号。 protocol 设置或返回当前 URL 的协议。 search 设置或返回从问号 (?) 开始的 URL（查询部分）。 *** 总结 使用 hash和search都能实现页面与页面之间传参数 如果只需要传一个参数，hash足够，比如我们刚讲的 展示图片 如果需要传多个参数，使用search ? 依赖之前的 strtoobj() navigator 浏览器信息对象 **** 内核 版本 http://www.w3school.com.cn/jsref/dom_obj_navigator.asp appVersion 返回浏览器的平台和版本信息。 userAgent 用途 判断IE 判断IE版本 判断PC端移动端进行页面跳转appVersion: “5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)appVersion: “5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/60 history 历史记录对象 （了解） go(number)往前走 back(number)往回走 页面跳转 超链接 href=”url” form表单 action=”url” window.open(url) location.href = url 各种宽和高client1可视宽或高 元素.clientWidth：获取元素的可视宽高 (width+左右的padding) 元素.clientHeight：获取元素的可视宽高 (height+左右的padding) 元素.clientTop：上边框 元素.clientLeft：左边框getStyle() document.documentElement.clientWidth：获取屏幕的可视宽 document.documentElement.clientHeight：获取屏幕的可视高 offset 元素.offsetWidth : 获取元素的占位宽（width+padding+border） 元素.offsetHeight : 获取元素的占位高（height+padding+border） 元素.offsetTop: 当前元素的顶部，到定位父元素的距离，没有定位父元素， 到body的距离 元素.offsetLeft: 当前元素的左边，到定位父元素的距离，没有定位父元素，到body的距离 scroll 元素.scrollTop : 获取元素被卷去的高 元素.scrollLeft：获取元素被卷去的宽 元素.scrollWidth : 获取元素实际内容宽 元素.scrollHeight : 获取元素实际内容高 123// 模拟自定义滚动条的思想实际内容的高-元素的可视高 = 最大的top值 //oDiv2.style.top = oDiv1.scrollHeight - oDiv1.clientHeight document.documentElement.scrollTop || document.body.scrollTop：获取页面被卷去的高 === 滚动条滚动的距离 document.body.scrollTop 老版本的谷歌浏览器“Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0”“Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36” window 事件 onscroll 滚动条事件 onload onresize 窗口改变大小触发的事项 封装位置 循环计算出每一个有相对父元素的相对距离，直到body 优化方案 减少网页的请求次数（雪碧图）（懒加载） css放到head里面 js 放尾部body的前面","categories":[],"tags":[]},{"title":"关于DOM的操作","slug":"关于DOM的操作","date":"2019-06-06T13:23:39.000Z","updated":"2019-06-06T13:34:35.560Z","comments":true,"path":"2019/06/06/关于DOM的操作/","link":"","permalink":"http://yoursite.com/2019/06/06/关于DOM的操作/","excerpt":"DOM 节点之间的关系 我们通过节点这个概念获取的元素，都是Object类型 节点类型 nodeType 元素节点 1 属性节点 2 文本节点 3 nodeName 要有兼容的意识 获取子节点 childNodes 标准属性 children 非标准属性（只获取元素类型的子节点） 获取节点当中的文本内容 nodeValue 文本 textContent 元素和文本 innerText innerHTML","text":"DOM 节点之间的关系 我们通过节点这个概念获取的元素，都是Object类型 节点类型 nodeType 元素节点 1 属性节点 2 文本节点 3 nodeName 要有兼容的意识 获取子节点 childNodes 标准属性 children 非标准属性（只获取元素类型的子节点） 获取节点当中的文本内容 nodeValue 文本 textContent 元素和文本 innerText innerHTML 属性 只有对象才有属性 自带属性和自定义属性 自带属性可以通过js的点语法，直接获取，带是自定义属性（如果在元素标签上直接添加的自定义属性，我们之前的点语法是不能获取的） 元素对象.getAttributeNode(属性名) 属性节点| 对象类型（ 了解 ）返回的对象.nodeValue 获取属性值 btn1.getAttribute(‘ccc’) 和点语法作用一模一样，返回字符串值，但是能获取标签上的自定义属性 父节点及相对父节点 parentNode === getElementById offsetParent : 最近的相对父元素，如果一直没找到，则返回的是body父元素上有 position:relative|absolute|fixed 其它节点 firstChild | firstElementChild firstChild 在标准浏览器当中能够获取文本节点也能获取到元素节点，在IE低版本下只获取元素节点如果就想获取元素节点，不能使用此方法获取，应该使用firstElementChild firstElementChild 在标准浏览器当中只能获取到元素节点，在IE低版本下无此属性 (undefined) 12345lastChild/lastElementChild：最后一个子元素/子节点nextSibling/nextElementSibling：下一个元素/节点previousSibling/previousSibling：前一个元素/节点firstChild标准浏览器会获取到折行，firstElementChild是专门解决这个问题的，但是两者不能共用。兼容：父元素.firstElementChild || 父元素.firstChild 节点操作属性节点操作 属性节点操作 读== 获取 元素.getAttribute( attrName ) 设置（赋值） | 修改元素.setAttribute( attrName,value ) 删除元素.removeAttribute( attrName ) 属性不会在页面上渲染 ，标签当中的内容才会被渲染 属性给开发者用的， 元素节点操作（都是依赖于父元素） 创建元素节点 document.createElement( ‘标签名’ )=&gt; 节点对象（元素对象）=== ById 通过createElement创建的元素，可以添加事件、设置样式 createTextNode(‘文本内容’) 创建文本节点 添加子元素（往父元素内部末尾追加） parentNode.appendChild( 节点对象[不是字符串] ) 元素.innerHTML+=’‘ var str = ‘’str+=’‘ 元素.innerHTML = str 在元素之前追加元素 parentNode.insertBefore(新节点,参考节点) 12345if( list.children[0] )&#123; list.insertBefore( oLi,list.children[0] )&#125;else&#123; list.appendChild( oLi )&#125; 删除元素 deleNode.remove() IE兼容性问题 父元素.removeChild( removeChildNode ) 没有兼容性问题 替换元素 父元素.replaceChild( 新的节点,参考节点 ) 克隆元素 被克隆的元素.cloneNode( boolean ) true|false 默认为false，只复制标签，true则复制内容及后代 这些方法都可以操作页面当中已有的元素，只不过是剪切操作 html5在js当中新增的两个选元素的方法 document.querySelector( selector ) 只选择一个 只选择页面当中第一个符合的元素 document.querySelectorAll( selector ) 选择所有符合css规则的元素注意：如果不考虑ie8以下浏览器，完全可以使用。如果在移动端完全可以使用 document.getElementsByClassName( className ) 也有兼容性问题 表格操作获取表格当中的元素 ( 了解 ) 表格.tHead : 获取表格thead 表格.tFoot : 获取表格tfoot 表格.tBodies : 获取表格tbody，获取到的是个元素集合，需要同[]获取 表格.rows：获取整个表格tr 表格.tBodies[0].rows：获取body中的tr 表格.rows[0].cells ：获取单元格，单元格必须通过行获取 document.div 表单 获取表单的元素当我们需要所数据传到另一个页面的时候，必须把表单写完整 需要form表单元素 哪个表单元素关心value，则在哪个表单元素上添加name属性 在一个表单当中，name名称不能重复 表单对象.name 表单事件 onsubmit 表单提交事件 普通按钮，不会触发onsubmit事件，type类型为submit的按钮才会触发表单提交事件 当点击type=’submit’的按钮，表单自动跳转（这个状态|这个行为称为浏览器中元素的默认行为） 如果我想阻止默认行为，就在触发此事件的事件函数中 最后面添加 return false formObj.onsubmit = fun oForm.onreset : 表单重置时调用 type类型为reset的按钮才会触发表单提交事件 input.onfocus : 获得焦点 input.onblur 失去焦点 表单提供的一些方法（函数） oForm.submit() :表单提交方法 oForm.reset()： 表单重置方法 input.focus()：获取焦点 input.blur(): 失去焦点 input.select()：选择表单元素中的文本内容方法","categories":[],"tags":[]},{"title":"函数小结","slug":"函数小结","date":"2019-06-02T14:58:37.000Z","updated":"2019-06-03T00:32:10.576Z","comments":true,"path":"2019/06/02/函数小结/","link":"","permalink":"http://yoursite.com/2019/06/02/函数小结/","excerpt":"函数常见错误 当使用未定义的变量或函数，则报 xxx is not defined 当数据不是函数的时候，但是你使用函数调用的方式则会报xxx is not a function 选元素null的时候绑定事件遇见的错误 语法错syntaxerror js上下文 分两步 预解析的过程（找东西的过程var 、function、参数） 找东西的过程是不执行表达式代码的，预解析完了才逐行执行表达式的代码，（表达式是能够改变预解析中内存中变量的值） 解析js代码时，会有一个预解析（ js所处的上下文环境是什么 ）的操作， 会先找到var和function还有和参数息息相关，然后逐行执行代码（表达式）","text":"函数常见错误 当使用未定义的变量或函数，则报 xxx is not defined 当数据不是函数的时候，但是你使用函数调用的方式则会报xxx is not a function 选元素null的时候绑定事件遇见的错误 语法错syntaxerror js上下文 分两步 预解析的过程（找东西的过程var 、function、参数） 找东西的过程是不执行表达式代码的，预解析完了才逐行执行表达式的代码，（表达式是能够改变预解析中内存中变量的值） 解析js代码时，会有一个预解析（ js所处的上下文环境是什么 ）的操作， 会先找到var和function还有和参数息息相关，然后逐行执行代码（表达式） 12345678910console.log(a);//console.log(d);//var a = 3;var d = function a()&#123; alert(&apos;1&apos;);&#125;;console.log(a);//console.log(d);//a();// 1234567function fn(a)&#123; console.log(a);// var a = 3; console.log(a);//&#125;fn(); 1234567function fn(a)&#123;// console.log(a);// var a = 3; console.log(a);//&#125;fn(2); 123456789var a = 4;function fn(b)&#123; console.log(a);// var a = 3; console.log(a);//&#125;;fn();console.log(a);// 123456789var a = 4;function fn(b)&#123; console.log(a);// a = 3; console.log(a);//&#125;;fn();console.log(a);// 123456789var a = 4;function fn(a)&#123; console.log(a);// a = 5; &#125;;fn(a);console.log(a);// 函数返回值 概念 1234567891011- 任何函数都有返回值（结果:任意类型的数据，我们学习的数据类型）- 而且只有函数才有返回值的概念- 函数只有在调用的时候才会产生返回值- 函数如果没有指定返回值则默认为undefined- 我们js当中是不是有很多内部函数 + getElementById ，如果正确获取则得到 element object,如果没有正确获取则得到 null- 我们指定返回值，在函数内部使用 `return 任意类型的数据[只能返回一个数据]`，如果想返回返回多个数据可以数组或者json形式的对象，你想返回什么（依据是你想得到什么？）- 在函数内部如果碰见return ，则函数内部return后面的代码不会执行（终止）- 没有返回值的函数，可以称作为一个 `单纯的过程`- 以后，我们函数封装（设计函数的功能） 很多情况下是离不开返回值的 123var a = 1var b = 2var arr = [a,b] 函数封装思想与复用 函数封装就是为了复用的 把功能实现，方便以后使用者很方便的完成自己的一些业务 什么时候要进行封装函数？（一定是有需求了，之前的功能不能满足现状了） 浏览器是有差异性的，尤其是操作元素的时候（渲染html、css、js）我们封装一些函数是非常有必要的。1.函数封装完以后，可以重复调用2.每一次调用都互相没有关系（因为每调用一次都会产生新上js上下文环境） 步骤 先把功能实现 把有关功能代码放到函数当中 把不确定（变化的值） 使用参数代替 关于样式注意事项 虽然有默认值的概念，但是我们也需要加上样式 复合样式写全backgroundfontbordermarginpadding 关于从页面上获取东西 获取了元素对象（null） 字符串 定时器 定时 器（功能） 每隔一段时间执行若干代码 定时器分类 ，其实就是函数（window全局下的函数） setInterval | clearInterval 每隔一段时间执行一次，无何止的执行 setTimeout | clearTimeout 只执行一次 定时器语法及特点 打开定时器|设置定时器 清除定时器 打开定时器语法id = setInterval( fn,间隔时间 )| 在js当中时间是以毫秒为单位 1000ms = 1s 每执行一次setInterval或setTimeout 它会返回一个唯一的数字ID标识 每一次返回的这个标识就是为了后续 要关的标记 设置定时器，至少传一个参数（必须传一个函数） 清除定时器 clearInterval( IntervalId ) clearTimeout( TimeoutId ) 脾气非常好，什么参数都可以传 当我们开启一个定时器前，必须先清除上一个定时器小方框移动 函数 当我们在描述一个功能的时候，就要能够想到封装一个函数 封装函数的时候，尽量避免依赖那么多页面元素 编辑 如果超链接不加一个空链接，则当点击超链接的时候，会刷新一下 getElementsByTagName() getElementById() 变量和函数起名 尽量不要使用一些特有的名词 left top bottom right 匀速运动封装 参数尽量少 参数 方向 速度 元素 属性 使用定时器公式 首先定义一个开启定时器的返回值变量 var timer ; 在你想要开启的位置开启 先清除定时器 再打开定时器 参数就是配置， 配置：通过配置可以产生不同的效果 config|options 轮播图 改变item父级容器的位置 使用绝对定位改变left","categories":[],"tags":[]},{"title":"js的进一步认知","slug":"js的进一步认知","date":"2019-06-01T13:09:18.000Z","updated":"2019-06-01T14:13:18.583Z","comments":true,"path":"2019/06/01/js的进一步认知/","link":"","permalink":"http://yoursite.com/2019/06/01/js的进一步认知/","excerpt":"循环语句for in循环专门用来遍历对象,对象有多少组属性，就循环几次 1234for(var key in obj)&#123; //key是一个变量，表示对象的属性名 //obj[key]:访问对象的属性值&#125; *如果对象中存在数字属性名，会优先按照数字升序遍历数字属性，其他的属性就按照定义的顺序遍历。 while循环 while 123456语法： ①初始化循环变量 while(②循环条件)&#123; ③循环体; ④更新循环变量; &#125; do while循环 1234语法： do&#123; 循环体; &#125;while(循环条件); dowhile和while大部分情况是相同的效果，当初始条件不满足的时候，do while会先执行一次循环体。 break和continue 都是用来中止循环 break: 结束整个循环 continue:结束本轮循环，继续下一轮循环","text":"循环语句for in循环专门用来遍历对象,对象有多少组属性，就循环几次 1234for(var key in obj)&#123; //key是一个变量，表示对象的属性名 //obj[key]:访问对象的属性值&#125; *如果对象中存在数字属性名，会优先按照数字升序遍历数字属性，其他的属性就按照定义的顺序遍历。 while循环 while 123456语法： ①初始化循环变量 while(②循环条件)&#123; ③循环体; ④更新循环变量; &#125; do while循环 1234语法： do&#123; 循环体; &#125;while(循环条件); dowhile和while大部分情况是相同的效果，当初始条件不满足的时候，do while会先执行一次循环体。 break和continue 都是用来中止循环 break: 结束整个循环 continue:结束本轮循环，继续下一轮循环 批量绑定事件的问题12345678var divs = document.getElementsByTagName(&apos;div&apos;);for(var i = 0; i &lt; divs.length; i++)&#123; divs[i].onclick = function()&#123; //事件处理函数里面不能再使用i，这里的i取到的值永远是循环结束后的i值 //this:事件处理函数里面的this指向的是当前触发事件的那个元素 &#125;&#125;? this能够找到触发事件的对象，但是我们还是没有解决获取不到 i 的问题？ 自定义属性 内置属性：元素天生自带的属性，例如 ele.id ele.class ele.src … 自定义属性 : 自己给元素添加的属性，为了配合实现某些功能，但是这个属性本身- 元素没有影响 打印对象详细信息console. d i r (); 打印对象详细信息 函数函数function: 函数是由时间驱动或当它被调用时可重复的代码块函数是用来保存代码块，在需要的时候调用。因此一个函数一般有两个操作： 声明和调用 函数本质的思想 把重复的代码放到函数当中，供我们使用 放到现当中，函数就是 工具 不同的工具有什么不同的功能。实现不同的功能，就要把不同的功能放到函数中。 函数声明 变量声明，按照现实当中，其实就应该先声明又这个东西，才能使用 123var a ; 变量的声明a = 23a+1 函数声明是使用function关键 只要函数声明就必须使用function关键字 函数声明，里面的代码不会自动执行。 函数当中代码的执行？ 事件调用函数（触发），执行当中的代码 主动调用（触发）函数声明完以后，只要有权限访问，可以调用多次 关键字12-语言当中已经把这个但系占用，有具体的安逸-function if for 匿名函数（无函数名）123function()&#123; 代码块&#125; 第一种形式 123function 函数名()&#123; 一些程序（ 代码块 ）&#125; 第二种形式 123 function 函数名(函数参数1,函数参数2,...)&#123; 一些程序（ 代码块 ）&#125; 第三种形式 1234 function 函数名(函数参数1,函数参数2,...)&#123; 一些程序（ 代码块 ） return 数据&#125; 第四种形式 1234 function 函数名()&#123; 一些程序（ 代码块 ） return 数据&#125; 函数表达式函数表达式: 只要函数和其他任意运算符结合起来，就不属于函数声明了 表达式： 由数据和运算符组成的式子才称为表达式 比如： 赋值表达式： a= 1+2 函数和其他运算符组成 123456789101112131415161718 fn1()console.log( fn1 )//undefinedfn1()//fn1 is not a function 因为数据不是函数类型 | 这是没有声明变量报的错 fn1 is not defined var fn1 = function () &#123; console.log(&apos;这是函数表达式，普通的等号&apos;)&#125; 函数表达式，一定是先有值才能使用。console.log( fn1 )fn1()/*函数声明：在前，在后都能访问到 */console.log( fn2 )fn2()function fn2() &#123; console.log( &apos;函数声明&apos; )&#125;console.log( fn2 )fn2() 对象中的方法123456789101112131415161718192021 *对象当中的函数，我们常常不叫函数，叫方法 函数|方法|工具对象当中能够有条件（属性） 1. 普通数据 2. 方法（函数）*/ var a = &apos;window的a&apos; var obj = &#123; a:&apos;我是a属性&apos;, fn1:function () &#123; console.log(&apos;我是obj当中的fn1&apos;) console.log( this.a ) &#125; &#125; console.log( typeof obj )//object console.log( obj.a ) console.log( obj.fn1 ) obj.fn1()//this-&gt;obj var fn = obj.fn1 fn() 参数 参数可以简单的理解为实际物体的配置选项，通过不同的配置，知道这个事物对象的一些特征 例子： 描述人这个对象姓名/出生年月日/性别/家庭住址 1234567891011121314151617人 = 姓名：xxx ; 出生的年月日 : xxxx; 性别: xxx，家庭住址:xxxx&lt;people 姓名=&apos;xxx&apos; 出生的年月日=&apos;xxx&apos; ......&gt;&lt;/people&gt;document.姓名 = xxxdocument.出生的年月日 = xxxdocument.性别 = xxxdocument.家庭住址 = xxxvar obj = &#123; 身份证号: xxx, 姓名 : xxx 出生的年月日 : xxx 性别 : xxx 家庭住址 : xxx &#125; 计算任意两个数的和 实际功能 把代码放入函数当中 把不确定的变量使用函数参数代替，只要调用的时候，把参数上传 1function 函数名（[[[参数1]，参数2],.....]）&#123;形参： 形式上的参数，参数可有可无，可以有1个也可以有多个&#125; 对象中的函数（方法） 对象中函数一般称其为——方法 函数|方法|工具 对象中能够有的条件（属性） 普通方法 方法（函数） 123456789101112131415var a = &apos;window的a&apos;var obj = &#123; a:&apos;我是a属性&apos;, fn1:function () &#123; console.log(&apos;我是obj当中的fn1&apos;) console.log( this.a ) &#125;&#125;console.log( typeof obj )//objectconsole.log( obj.a )console.log( obj.fn1 )obj.fn1()//this-&gt;objvar fn = obj.fn1fn() 传递多个参数1234567891011121314151617181920212223function sum(n1,n2) &#123;//n1，n2 形参，占个坑（占位） 就把它看作变量就完了 /* 当调用的时候，如果没有传参数， 则js内部只是做了 var n1,n2 如果传参数了则实参 一一对应把值赋给形参 */ var a = n1 var b = n2 console.log( a + b )// console.log( n1,n2 )//undefined&#125;//sum()//没有传参数 没有传则 则形参的值为undefinedsum( 11,22 )//实参，具体的数据console.log(&apos;---------------------------------------&apos;)function su2(n1,n2) &#123; console.log( n1 + n2 )&#125;su2( 10,20 ) 参数的注意事项12345678910function fn(a,b,c,d) &#123; console.log(&apos;a:&apos;,a) console.log(&apos;b:&apos;,b) console.log(&apos;c:&apos;,c) console.log(&apos;d:&apos;,d) &#125;//fn()//undefinedfn(11,22)//不会报错的 a:11,b:22 c,d : undefined 我们之前所学的所有的数据类型的值 ，都可以传到函数内部供函数使用。 但是 null undefined我们很少用到。 错误优先思想12345678910111213141516function fn1( obj,bgc ) &#123; 默认值的概念 /*if( typeof bgc == &apos;undefined&apos; )&#123; bgc = &apos;red&apos; &#125;*/ 错误优先思想 /*if( !bgc )&#123; bgc = &apos;red&apos; &#125; */ bgc = (bgc?bgc:&apos;red&apos;) obj.style.background = bgc &#125; // fn1( oBtn,&apos;blue&apos; ) fn1( oBtn,&apos;pink&apos; ) arguemnts概念 arguments是一个（类似数组）的对象 存储的就是实际参数 无论是否有形参，arguments对象都会存储具体的实参 length属性 通过下标不确定的时候使用 在参数个数不确定时使用 123456789101112131415161718192021语法应用 function fn() &#123; //console.log( arguments ,typeof arguments)//object //console.log( arguments ) for( var i=0;i&lt;arguments.length;i++ )&#123; console.log( arguments[i] ) &#125; //console.log( arguments[2] )//true &#125; //fn()//没有传递实参，所以函数内部的arguments的长度为0 //fn( 1,&apos;abc&apos;,true,document ) // console.log( arguments )//在函数外部不存在 function sum(n1,n2) &#123; var result = 0 console.log( n1,n2 )//1,2 for( var i=0;i&lt;arguments.length;i++ )&#123; result += arguments[i] &#125; console.log( result ) &#125; sum( 1,2,3,3,4,6 ) 函数的注意事项 相同的函数名，会把之前的替换掉 123456789 function fn() &#123; console.log(&apos;我是第1次定义的函数fn&apos;)&#125;function fn() &#123; console.log(&apos;我是第2次定义的函数fn&apos;)&#125;//fn() //我是第2次定义的函数fn 表达式就是运算，运算可以改变变量的初始值 1234var fn = function () &#123; console.log(&apos;变量赋值&apos;)&#125;fn() 作用域 概念 域：是否有权限访问到变量或者函数 全局作用域 在函数外部定义的变量或函数 都属于全局的（ window ） 局部作用域（ 函数作用域 ） 变量或函数在函数内部定义(声明)的 局部变量或局部函数 变量必须使用var声明,如果没有var则代表全局的 函数声明必须有function 私有成员 这个变量或函数 只能在这个屋子里面访问到 作用域链 函数嵌套函数才可以形成链条( 作用域链 ) 当前函数想访问一个变量或函数，如果当前函数没有此变量或函数，则一层一层往上找，直到script标签顶层，如果还没有找到，则报 xxx is not defined 变量或函数是就近原则 局部作用域局部作用域（函数作用域）1234567891011121314151617181920212223242526272829 console.log( a )//undefined 这不是报错 var a = &apos;我是全局下的a&apos; console.log( fn ) function fn() &#123; console.log( &apos;我是全局下的fn&apos; ) &#125; function fn1() &#123; console.log( a ) &#125; fn1()function fn2() &#123; var a = &apos;我是fn2内部的变量a&apos; function fn() &#123; console.log( &apos;我是fn2内部的fn&apos; ) &#125;&#125;fn2()// 就算执行，在函数外部也是访问不到的console.log( a )//a is not defined 在函数内部，我们就想定义私有变量，就应该必须 带var123456789101112function fn3() &#123; a = &apos;aaaaa&apos; function fn() &#123; &#125;&#125;fn3()console.log( a )fn()// fn is not defined 作用域链123456789101112131415var a = &apos;script 中的a&apos;function fn1() &#123; var a = &apos;fn1作用域 下的a&apos; function fn2() &#123; var a = &apos;fn2作用域下的a&apos; function fn3() &#123; console.log( a ) var a &#125; fn3() &#125; fn2()&#125;fn1()// undefined 1234567891011121314151617var a = &apos;script 中的a&apos;function fn1() &#123; var a = &apos;fn1作用域 下的a&apos; function fn2() &#123; var a = &apos;fn2作用域下的a&apos; function fn3() &#123; console.log( a ) //var a &#125; fn3() &#125; fn2()&#125;fn1()// fn2作用域下的a 123456789101112131415161718//var a = &apos;script 中的a&apos;function fn1() &#123; //var a = &apos;fn1作用域 下的a&apos; function fn2() &#123; //var a = &apos;fn2作用域下的a&apos; function fn3() &#123; console.log( a ) //var a &#125; fn3() &#125; fn2()&#125;fn1()// 报错 fn is not defined script标签的特点 从上往下执行的 代码分离 使用外部的js文件当中的数据（变量和函数） 先引入后使用 关于null和undefined var a,b,c,d console.log( a,b,c,d )//变量声明未赋值，在变量声明之前变量当中存储的为undefined 形参中，函数调用的时候，如果没有传实参则为undefined 当你这个变量不知道以后要存储什么值，则直接声明就可以 null 是属于空对象（虚无缥缈的东西）是不能加任何属于的。 它和{} 不一样 当你确定这个变量以后会存储一个对象，则你可以声明值为null，实际当中什么时候为会得到null？ 当我们选元素的时候？ 是你逻辑错了，则会得到 null 我就知道这个页面上目前还没有这个元素，但是我选了。则也会得到 null 12345var obtn = document.getElementById(&apos;btn&apos;)obtn.onclick = function () &#123; alert(123)&#125; js的与解析（js的上下文环境） 普通的变量和函数 参数 表达式 函数执行 ###浏览器当中的js渲染引擎解析js代码时，会有一个预解析（ js所处的上下文环境是什么 ）的操作，会先找到var和function还有和参数息息相关，然后逐行执行代码（表达式） 先预解析：分析上下文环境找var 找function（是函数声明）如果是var代表变量声明，则先在内存当中 把变量存储一个undefined如果是function函数声明，则把函数整体存储在内存当中如果函数名和变量名相同（ 函数的优先级大于变量的 ） 123var a = function a() &#123; console.log( 4 )&#125; 分析完上下文以后，逐行执行表达式代码表达式：运算符组成的式子都是表达式，函数执行也属于表达式 : 改变内存当中的变量的值 12345678910111213141516171819202122232425console.log( a ) /*function a() &#123; console.log( 4 )&#125;*/var a = 1;console.log( a )//1var a = function () &#123; console.log(2)&#125;console.log( a )/*function () &#123; console.log(2)&#125;*/a = 3console.log( typeof a )//numbera()// 报错 a is not a functionfunction a() &#123; console.log( 4 )&#125;","categories":[],"tags":[]},{"title":"","slug":"js的认识","date":"2019-06-01T12:53:08.934Z","updated":"2019-06-01T14:14:05.683Z","comments":true,"path":"2019/06/01/js的认识/","link":"","permalink":"http://yoursite.com/2019/06/01/js的认识/","excerpt":"Js的初步认知js: 原生js 15 项目 4 jquery 5 网页三层结构： 结构 表现 行为 三门核心技术： html css js js历史 1995 网景公司 livescript –&gt; javascript 三种类似js脚本 javascript 微软JScript - ScriptEase ECMA : 欧洲计算机制造商协会 ECMASCript :标准 es5 es6 :es2015 组成（核心） ECMASCript：提供变量、运算符、操作语句、关键字。。。，定义和js语言最核心的语法 DOM(document object model):文档对象模型，定义了js如何操作html文档，比如获取输入框的值，操作标签样式。。。 BOM(browser object model):浏览器对象模型，定义js如何操作浏览器。比如打开关闭窗口，获取浏览器版本信息。。。","text":"Js的初步认知js: 原生js 15 项目 4 jquery 5 网页三层结构： 结构 表现 行为 三门核心技术： html css js js历史 1995 网景公司 livescript –&gt; javascript 三种类似js脚本 javascript 微软JScript - ScriptEase ECMA : 欧洲计算机制造商协会 ECMASCript :标准 es5 es6 :es2015 组成（核心） ECMASCript：提供变量、运算符、操作语句、关键字。。。，定义和js语言最核心的语法 DOM(document object model):文档对象模型，定义了js如何操作html文档，比如获取输入框的值，操作标签样式。。。 BOM(browser object model):浏览器对象模型，定义js如何操作浏览器。比如打开关闭窗口，获取浏览器版本信息。。。 三种方式： 行间（行内） 12&lt;div 事件属性=&quot;js代码&quot;&gt; ... &lt;/div&gt;&lt;div onclick=&quot;alert(&apos;hello world&apos;);&quot;&gt;点我弹窗&lt;/div&gt; 内部（内嵌） 12&lt;script&gt; &lt;/script&gt;:脚本块之间写的是js的代码，不能写标签 外部（外联） 123&lt;script src=&quot;script.js&quot;&gt; 外部样式脚本块之间的代码不会运行&lt;/script&gt; js注释12单行 //多行 /* .... */ 变量： 就是一个命名的容器，可以用来存储数据和代表数据 声明： var 变量名 = 值（数据）; *变量需要先声明再使用 命名规则 1)、可以包含数字、字母、下划线、$,不能以数字开头 2)、不能使用关键字和保留字 3)、变量名不能相同，如果相同后面会覆盖前面 4）、区分大小写， a 和 A 是两个不同的变量 5）、规范：推荐驼峰命名：第一个单词首字母小写，之后的每一个单词首字母大写，例如 userName,passWord调试语句12alert( ); 弹出框提示console.log( ); 在控制台中输出 交互过程1）找到谁 （获取元素） var oBox = document.getElementById(&apos;id&apos;); 2）什么事件 oBox.onclick = function(){ .... } 3）发生什么事（事件发生之后要做什么） oBox.onclick = function(){ 这里面就定义事件发生之后要做什么 }文档就绪事件 如果想把js加到head里面，就需要使用文档就绪事件 window.onload = function(){ 这里面是所有js的操作 } 如果标签不存在，获取回来结果是null 鼠标常用事件onclick 点击事件ondblclick 双击事件onmouseover 鼠标移入onmouseout 鼠标移出onmouseenter 鼠标进入onmouseleave 鼠标离开onmousedown 鼠标按下onmouseup 鼠标抬起oncontextmenu 右键菜单事件 操作元素内容 双标签 操作(获取和设置)内容 设置：ele.innerHTML = “内容”; 获取：ele.innerHTML innerHTML : 设置或者获取标签之间的HTML代码（可以识别标签） innerText : 设置或者获取标签之间的文本（不能识别标签） 表单元素操作(获取和设置)input或者textarea的值 设置：ele.value = &quot;值&quot; 获取：ele.value 操作元素属性123456&lt;div id=&quot;&quot; class=&quot;&quot; &gt;&lt;/div&gt;&lt;img src=&quot;&quot; alt=&quot;&quot;&gt;&lt;a href=&quot;&quot; target=&quot;&quot;&gt;&lt;/a&gt;&lt;input type=&quot;&quot; value=&quot;&quot;大部分属性都是直接用 元素.属性名操作 例如： ele.id 、ele.src 、ele.href ...特殊情况：因为class是一个关键字,class的操作使用的是className属性 样式操作ele.style.样式属性 复合属性：带“-”的属性需要改为驼峰命名方式 例如：font-size 标签.style.fontSize ele.style.cssText: 操作style属性值这个整体 oBox.style.cssText = &quot;width:100px;height: 100px;background-color: red;&quot;;数据类型 基本数据类型 数字（number）、字符串（string）、布尔（boolean）、空（mull）、未定义（undefined） number:正数、负数、0、小数、八进制、十六进制、NaN string : “xxx” 用引号引起来的字符串 想要访问其字符串中的指定字符 str[下标 ] *下标从开始 boolean : 只有两个值 ture(真)、flase(假) null : 只有一个值null 代表空 undefined : 变量、函数参数、返回值在未赋值的时候默认值都是undefined 基本数据类型的特点： 架构简单、存在内存中 引用数据类型 对象（object）函数（function） object : 数组（array）、json、正则（regExp）这几个都是不同类型的对象 字面量方式 : var obj = {name: ‘小明’，age:18} 构造函数方式 : var obj2 = new Object() array : 表示的是数组 [1,2,3] regExp : 正则 /字符/ function： 函数 创建函数 : function 函数名（） 使用函数 : 函数名（） 特点: 结构复杂，存在堆内存中，变量存在的是堆内存的地址数据检测 typeof : nember string boolean undefined 能够检测的出来的类型 null 检测出来是object 引用数据类型用 typeof检测出来的结果大部分是object 除了function检测出来时function 所以typeof 一般是用来检测基本数据类型 instanceof: 判断一个对象是否属于某个类的实例，通常用来判断引用数据类型数据类型的转换 隐式转换 算术运算符，左右两边的值后隐式转换为number类型再进行运行算（除了‘+’） isNaN（）： 判断一个值是否是一个有效数字，有效数字返回为false，不是的返回true 强制转换 Namer()强制转换成数字： Namer(‘123’)——&gt;123/ ‘12.234’ – &gt; 12.123 ‘’ –&gt; 0 true –&gt; 1/false –&gt; 0 null –&gt; 0 [] –&gt; 0 [12] –&gt; 12 [‘12’] –&gt; 12 paseInt()强制转换成整型数字（即整数） 从左到右查找数字，直到遇到非数字为止，返回已经找到的数字 ‘12px’ – &gt; 12 paseFloat()强制转换成浮点数字（即识别小数点） 跟parseInt()类似，比parseInt多识别一个小数点 ‘12.5px’–&gt;’12.5’ toString()强制转换成字符串 （1）转换成字符串，大部分的值都是直接加引号 （2）数组是去掉中括号[],再加引号，所有的{}对象 ，转出来结果都是 ‘[object Object]’ （3）null 和undefined不能调用toString()方法 语法： 检测的变量.toString() String() 和toString()效果相同，String()可以用来转换null和undefined 语法：String(检测的变量) Blooean()强制转换成布尔类型 ‘’ 0 NaN null undefined :这几个值转成布尔都是false。其余的值转换成布尔都是true比较运算符 == ：等于，如果数据类型不相同，会进行隐式转换成相同的类型再比较 === ：全等，数据类型和值都必须相同才返回true ‘&gt;’ : 大于 &lt; :小于 ‘&gt;=’ :大于等于 &lt;= :小于等于 != : 不等 !== : 不全等赋值运算符 = : 赋值 +=： x+=y; –&gt; x=x+y; -=: x-=y; –&gt; x=x-y; =: x=y; –&gt; x=x*y; /=: x/=y; –&gt; x=x/y; %=: x%=y; –&gt; x=x%y;逻辑运算符 &amp;&amp; :且(与) ，左右两边都为true，整个表达式才成立 || :或 ，左右两边都有一边为true，整个表达式就成立 *&amp;&amp;和||运算的结果返回的是决定表达式最终结果的那一边的值。 !：非（取反）三目运算符 条件 ？ 条件成立执行的语句 : 条件不成立执行的语句;流程控制 顺序结构、分支结构（选择结构）、循环结构 分支语句 if语句 if(条件){ 条件成立执行的代码 } if(条件){ 条件成立执行的代码 }else{ 条件不成立执行的代码 } 1234if(条件1)&#123; 条件1成立执行的代码 &#125;else if(条件2)&#123; 条件1成立执行的代码 &#125;....else&#123; 前面的条件都不满足执行的代码 &#125; switch语句 switch(表达式或者变量){ case 值1 : 代码;break; case 值2 : 代码;break; case 值3 : 代码;break; …. default:前面的情况都不满足执行的代码;} switch语句中变量和case后面的值之间的比较是绝对比较（===） 循环语句for循环 for(①循环的初始变量;②循环条件;④累加或递减操作){③循环体(反复运行的代码)} 执行顺序： 初始化循环变量① 判断循环条件②：如果满足循环条件，执行循环体代码③；如果不满足循环条件，结束 循环体执行之后，累加或递减循环变量④ 回到第2）步判断循环条件 获取元素方法 通过id获取元素 12document.getElementById(&apos;id&apos;); //单个标签* 只能通过document对象调用 通过标签名获取元素 123context.getElementsByTagName(&apos;div&apos;) ; context:上下文，可以是document或者是一个具体的元素 获取的结果是一个类数组 [div,div] 通过类名获取元素 123context.getElementsByClassName(&apos;class&apos;) ;context:上下文，可以是document或者是一个具体的元素获取的结果是一个类数组 [div,div]","categories":[],"tags":[]}]}